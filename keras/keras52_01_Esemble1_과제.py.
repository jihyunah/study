# csv 파일의 날짜를 오름차순으로 변환하기 0
# 여러개의 컬럼중에 5개 임의로 고를 것 0 --> 시가, 종가, 거래량, 고가, 저가 
# 앙상블 소스와 가중치를 제출 --> 가중치는 모델체크포인트로 파일로 해서 내기.   --> 삼성 월요일 시가를 맞추기. 
# 삼성전자의 1/30 월요일 시가를 맞추는게 문제인데, 그럼 x_predict를 무엇으로 넣어야 하는지를 모르겠습니다!!. 
# 메일 제목 : 이지현 78,700원
# 1등 ~ 5등까지 시상. 


import numpy as np 
import pandas as pd
import tensorflow as tf
from sklearn.model_selection import train_test_split
from tensorflow.python.keras.models import Model
from tensorflow.python.keras.layers import Dense, Flatten, Input, Conv1D, Dropout, MaxPooling1D
from tensorflow.python.keras.callbacks import EarlyStopping, ModelCheckpoint
 
#1. 데이터
path = '/Applications/study/keras/_data/samsung_jusik/'
samsung_csv = pd.read_csv(path + 'samsung.csv', index_col=0, encoding='cp949')
amore_csv = pd.read_csv(path + 'amore.csv', index_col=0, encoding='cp949')
# submission = pd.read_csv(path + 'submission.csv', index_col=0)

samsung_csv = samsung_csv.sort_index()  # index를 오름차순으로 바꿔준다. 
amore_csv = amore_csv.sort_index()
print(amore_csv)


print(samsung_csv)
print(samsung_csv.shape) # [1980 rows x 16 columns]
print(samsung_csv.columns) # ['시가', '고가', '저가', '종가', '전일비', 'Unnamed: 6', '등락률', '거래량', '금액(백만)',
    #    '신용비', '개인', '기관', '외인(수량)', '외국계', '프로그램', '외인비'],
    #   dtype='object')
print(samsung_csv.info()) # 결측치 있는 것을 확인할 수 있음. 

# samsung_csv = samsung_csv.dropna() # samsung_csv의 결측치 모두 삭제


print(amore_csv)
print(amore_csv.shape) # [2220 rows x 16 columns]
print(amore_csv.columns)  # ['시가', '고가', '저가', '종가', '전일비', 'Unnamed: 6', '등락률', '거래량', '금액(백만)',
    #    '신용비', '개인', '기관', '외인(수량)', '외국계', '프로그램', '외인비']
print(amore_csv.info())
# amore_csv = amore_csv.dropna()  # amore_csv의 결측치 모두 삭제 

print(samsung_csv.info())
print(amore_csv.info())    # 결측치 삭제된 것을 확인할 수 있음





x1_datasets = samsung_csv[['시가', '종가', '고가', '저가', '거래량']]
print(x1_datasets.shape) # (1980, 5)
print(x1_datasets) # (1980, 5)

x2_datasets = amore_csv[['시가', '종가', '고가', '저가', '거래량']]
print(x2_datasets.shape) # (2220, 5)

y = samsung_csv['시가']
print(y)
print(y.shape) # (1980, )

x_predict = np.array([[[64400], [65000], [63900], [64600], [18154371]]])
print(x_predict.shape) # (1, 5, 1)



x1_train, x1_test, y_train, y_test = train_test_split(
    x1_datasets, y, train_size=0.7, random_state=1234)

print(x1_train.shape, y_train.shape) # (1386, 5) (1386, )
print(x1_test.shape, y_test.shape) # (594, 5) (594, ) # 잘 train,test 잘린거 알 수 있음 

x2_train, x2_test = train_test_split(x2_datasets, train_size=0.7, random_state=1234)
print(x2_train.shape) # (1554, 5)
print(x2_test.shape) # (666, 5)



x1_train = x1_train.to_numpy()
x1_test = x1_test.to_numpy()
x2_train = x2_train.to_numpy() 
x2_test = x2_test.to_numpy()

x1_train = x1_train.reshape(1386, 5, 1)
x1_test = x1_test.reshape(594, 5, 1)
x2_train = x2_train.reshape(1554, 5, 1)
x2_test = x2_test.reshape(666, 5, 1)




# x1_train = np.asarray(x1_train).astype(np.float32)
# x2_train = np.asarray(x2_train).astype(np.float32)
# y_train = np.asarray(y_train).astype(np.float32)


#2. 모델구성

#2-1. 모델 1 삼성.
input1= Input(shape=(5, 1))
dense1= Conv1D(64, 2, padding='same', activation='relu', name='ds11')(input1)
dense2= Conv1D(64, 2, padding='same', activation='relu', name='ds12')(dense1)
dense3= Conv1D(128, 2, padding='same', activation='relu', name='ds13')(dense2)
dense4= Conv1D(128, 2, padding='same', activation='relu', name='ds14')(dense3)
dense5= Conv1D(256, 2, padding='same', activation='relu', name='ds16')(dense4)
dense6= Conv1D(256, 2, padding='same', activation='relu', name='ds17')(dense5)
dense7= Conv1D(256, 2, padding='same', activation='relu', name='ds18')(dense6)
dense8= Conv1D(512, 2, padding='same', activation='relu', name='ds20')(dense7)
dense9= Conv1D(128, 2, padding='same', activation='relu', name='ds24')(dense8)
dense10= Conv1D(128, 2, padding='same', activation='relu', name='ds25')(dense9)
dense11= Conv1D(128, 2, padding='same', activation='relu', name='ds26')(dense10)
dense12= Flatten(name='ds28')(dense11)
output1= Dense(32, activation='relu', name='ds29')(dense12)   # concatenate 의 input

# 머지 할 것이기 때문에 아직 output 내지 않음. 

#2-2. 모델 2.
input2= Input(shape=(5, 1))
dense21= Conv1D(64, 2, padding='same', activation='relu', name='ds31')(input2)
dense22= Conv1D(64, 2, padding='same', activation='relu', name='ds32')(dense21)
dense23= Conv1D(128, 2, padding='same', activation='relu', name='ds34')(dense22)
dense24= Conv1D(128, 2, padding='same', activation='relu', name='ds35')(dense23)
dense25= Conv1D(256, 2, padding='same', activation='relu', name='ds37')(dense24)
dense26= Conv1D(256, 2, padding='same', activation='relu', name='ds38')(dense25)
dense27= Conv1D(256, 2, padding='same', activation='relu', name='ds39')(dense26)
dense28= Conv1D(512, 2, padding='same', activation='relu', name='ds41')(dense27)
dense29= Conv1D(512, 2, padding='same', activation='relu', name='ds42')(dense28)
dense30= Conv1D(512, 2, padding='same', activation='relu', name='ds43')(dense29)
dense31= Conv1D(128, 2, padding='same', activation='relu', name='ds45')(dense30)
dense32= Conv1D(128, 2, padding='same', activation='relu', name='ds46')(dense31)
dense33= Conv1D(128, 2, padding='same', activation='relu', name='ds47')(dense32)
dense34= Flatten(name='ds49')(dense33)
output2= Dense(64, activation='relu', name='ds50')(dense34)
# dense21= Dense(21, activation='linear', name='ds21')(input2)
# dense22= Dense(22, activation='linear', name='ds22')(dense21)
# output2= Dense(23, activation='linear', name='ds23')(dense22)  # concatenate 의 input

#2-3. 모델병합
from tensorflow.python.keras.layers import concatenate  # concatenate 사슬같이 잇다; 연쇄시키다;
merge1 = concatenate([output1, output2], name='mg1') # 2개 이상은 리스트 형태
merge2 = Dense(128, activation='relu', name='mg2')(merge1)
merge3 = Dense(64, activation='relu', name='mg3')(merge2)
merge4 = Dense(32, activation='relu', name='mg4')(merge3)
merge5 = Dense(16, activation='relu', name='mg5')(merge4)
merge6 = Dense(8, activation='relu', name='mg6')(merge5)
last_output = Dense(1, name='last')(merge6)

model = Model(inputs=[input1, input2], outputs=last_output)  # 모델이 두개라서 인풋이 2개임. 

model.summary()


#3. 컴파일, 훈련
model.compile(loss='mse', optimizer='adam', metrics=['acc'])

es = EarlyStopping(monitor='val_loss', mode='min', restore_best_weights=True, patience=20, verbose=1)

import datetime 
date = datetime.datetime.now()
date = date.strftime('%M%D_%H%M')

filepath = '/Applications/study/keras/_save/MCP/'
filename = '{epoch:04d}-{val_loss:.4f}.hdf5'

mcp = ModelCheckpoint(monitor='val_loss', mode='min', save_best_only=True, verbose=1, 
                      filepath= filepath + 'k34_1_' + date + '_' + filename)

# x1_train = np.asarray(x1_train).astype(np.float64)
# x2_train = np.asarray(x2_train).astype(np.float64)
# y_train = np.asarray(y_train).astype(np.float64)

model.fit([x1_train, x2_train], y_train, epochs=200, batch_size=8)


#4. 평가, 예측
loss = model.evaluate([x1_test, x2_test], y_test)
print('loss:', loss)

result = model.predict(x_predict)
print('1/30 삼성전자 시가 예측값:', result)

# 날짜를 순서대로 변환. 
# 여러개의 컬럼중에 5개 임의로 고를 것. 
# 앙상블 소스와 가중치를 제출 --> 가중치는 모델체크포인트로 파일로 해서 내기.   --> 삼성 월요일 시가를 맞추기. 
# 메일 제목 : 이지현 78,700원
# 1등 ~ 5등까지 시상. 
